/*
    ? Problem: Q1 of assignment 12.

    ! Time Complexity:
        !- hashFunction: O(n)
        !- addNum: O(1) [If we consider the time complexity of hasFunction then it becomes O(n)]
        !- getNum: O(1) [If we consider the time complexity of hasFunction then it becomes O(n)]
    ! Space Complexity: O(n)

    ! Approach: Mid Square Method (This methos does not take care of the collision)
*/

class HashTable {
    MAX_SIZE: number;
    numArray: Array<number>;

    // * This is the constructor. It initializes an array with the MAX_SIZE.
    constructor() {
        this.MAX_SIZE = 10;
        this.numArray = new Array(this.MAX_SIZE);
    }

    // * This function generates the hash index where the data would be stored.
    hashFunction(key: string): number{
        // * We initiate a characterOrdValue variable with 0.
        let characterOrdValue = 0;

        // * Here we go over each and every number in the key and generate sum of their ASCII value.
        for(let i=0; i<key.length; i++){
            characterOrdValue += key.charCodeAt(i);
        }

        // * We are calculating the square of characterOrdValue
        characterOrdValue = characterOrdValue ** 2;

        // * We calculate length of the index we need & also find out how many number needs to be discarded. 
        let indexLength = (this.MAX_SIZE - 1).toString().length;
        let numberOfIndexToBeLeft = characterOrdValue.toString().length - indexLength;

        // * Numbers to be discarded is zero then we return the current characterOrdValue
        if(numberOfIndexToBeLeft === 0) return characterOrdValue;

        // * We are checking how many numbers are needed to be left from right.
        let numberOfIndexesToBeLeftFromRight = Math.ceil(numberOfIndexToBeLeft / 2);

        // * Finally we discard the required numbers from the right.
        for(let i=0; i<numberOfIndexesToBeLeftFromRight; i++) {
            characterOrdValue = Math.floor(characterOrdValue / 10);
        }

        // * We then assign a new index as 0.
        let index = 0;

        // * Now extract the number of the digits required and combine them via the algo given below and update the index.
        /*
            * If i or position is one's place then simply the update the index.
            * If i is more than 0, then we simply do the (extracted value * (10 ** i)) + index and update the index.
        */
        for(let i=0; i<indexLength; i++){
            let currentNum = characterOrdValue % 10;

            if(i == 0) index = currentNum;
            else index = (currentNum * (10 ** (i))) + index;
        }

        // * Finally we return the index.
        return index;
    }

    // * This function is responsible for adding the number in the array on the index generated by hash function.
    addNum(key: string, val: number): void {
        let index = this.hashFunction(key);

        this.numArray[index] = val
    }

    // * This function is responsible for getting the number from the array on the given index generated by hash function.
    getNum(key: string): number | undefined {
        let index = this.hashFunction(key);

        return this.numArray[index];
    }
}

// ? Driver Code
const hashTable = new HashTable();

hashTable.addNum("March 2020", 234);
hashTable.addNum("March 2021", 345);
hashTable.addNum("March 2022", 445);
hashTable.addNum("March 2023", 553);
hashTable.addNum("March 2025", 678);
hashTable.addNum("March 2026", 789);
hashTable.addNum("March 2027", 598);

// * These two values will have a collision with second and third.
hashTable.addNum("March 2028", 569);
hashTable.addNum("March 2029", 987);

console.log(hashTable.getNum("March 2021"));
console.log(hashTable.getNum("March 2023"));

// * This would return undefined as this will not be there in the table.
console.log(hashTable.getNum("nfsakjbfhkjabfkh"));
